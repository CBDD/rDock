#! /usr/bin/env python
#
# Calculate SMART RMSD with or without molecular superposition (FIT or NOFIT) 
# Script distributed under GNU LGPL 3.0 along rDock software.
# 
# This algorithm takes into account molecular automorphism. That is, it identifies
# molecules which are the same but might have atom orders changed and still be able to 
# match the pairs and correctly calculate the RMSD.
#
# Author: Daniel Alvarez-Garcia
# Date: 08-11-2013

import math
import pybel
import numpy as npy
import optparse

def superpose3D(ref, target, weights=None,refmask=None,targetmask=None,returnRotMat=False):
    """superpose3D performs 3d superposition using a weighted Kabsch algorithm : http://dx.doi.org/10.1107%2FS0567739476001873 & doi: 10.1529/biophysj.105.066654
    definition : superpose3D(ref, target, weights,refmask,targetmask)
    @parameter 1 :  ref - xyz coordinates of the reference structure (the ligand for instance)
    @type 1 :       float64 numpy array (nx3)
    ---
    @parameter 2 :  target - theoretical target positions to which we should move (does not need to be physically relevant.
    @type 2 :       float 64 numpy array (nx3)
    ---
    @parameter 3:   weights - numpy array of atom weights (usuallly between 0 and 1)
    @type 3 :       float 64 numpy array (n)
    @parameter 4:   mask - a numpy boolean mask for designating atoms to include
    Note ref and target positions must have the same dimensions -> n*3 numpy arrays where n is the number of points (or atoms)
    Returns a set of new coordinates, aligned to the target state as well as the rmsd
    """
    if weights == None :
        weights=1.0
    if refmask == None :
        refmask=npy.ones(len(ref),"bool")
    if targetmask == None :
        targetmask=npy.ones(len(target),"bool")
    #first get the centroid of both states
    ref_centroid = npy.mean(ref[refmask]*weights,axis=0)
    #print ref_centroid
    refCenteredCoords=ref-ref_centroid
    #print refCenteredCoords
    target_centroid=npy.mean(target[targetmask]*weights,axis=0)
    targetCenteredCoords=target-target_centroid
    #print targetCenteredCoords
    #the following steps come from : http://www.pymolwiki.org/index.php/OptAlign#The_Code and http://en.wikipedia.org/wiki/Kabsch_algorithm
    # Initial residual, see Kabsch.
    E0 = npy.sum( npy.sum(refCenteredCoords[refmask] * refCenteredCoords[refmask]*weights,axis=0),axis=0) + npy.sum( npy.sum(targetCenteredCoords[targetmask] * targetCenteredCoords[targetmask]*weights,axis=0),axis=0)
    reftmp=npy.copy(refCenteredCoords[refmask])
    targettmp=npy.copy(targetCenteredCoords[targetmask])
    #print refCenteredCoords[refmask]
    #single value decomposition of the dotProduct of both position vectors
    try:
        dotProd = npy.dot( npy.transpose(reftmp), targettmp* weights)
        V, S, Wt = npy.linalg.svd(dotProd )
    except Exception:
        try:
            dotProd = npy.dot( npy.transpose(reftmp), targettmp)
            V, S, Wt = npy.linalg.svd(dotProd )
        except Exception:
            print >> sys.stderr,"Couldn't perform the Single Value Decomposition, skipping alignment"
        return ref, 0
    # we already have our solution, in the results from SVD.
    # we just need to check for reflections and then produce
    # the rotation.  V and Wt are orthonormal, so their det's
    # are +/-1.
    reflect = float(str(float(npy.linalg.det(V) * npy.linalg.det(Wt))))
    if reflect == -1.0:
        S[-1] = -S[-1]
        V[:,-1] = -V[:,-1]
    rmsd = E0 - (2.0 * sum(S))
    rmsd = npy.sqrt(abs(rmsd / len(ref[refmask])))   #get the rmsd
    #U is simply V*Wt
    U = npy.dot(V, Wt)  #get the rotation matrix
    # rotate and translate the molecule
    new_coords = npy.dot((refCenteredCoords), U)+ target_centroid  #translate & rotate
    #new_coords=(refCenteredCoords + target_centroid)
    #print U
    if returnRotMat : 
        return new_coords,rmsd, U
    return new_coords,rmsd


def squared_distance(coordsA, coordsB):
    """Find the squared distance between two 3-tuples"""
    sqrdist = sum( (a-b)**2 for a, b in zip(coordsA, coordsB) )
    return sqrdist
    
def rmsd(allcoordsA, allcoordsB):
    """Find the RMSD between two lists of 3-tuples"""
    deviation = sum(squared_distance(atomA, atomB) for
                    (atomA, atomB) in zip(allcoordsA, allcoordsB))
    return math.sqrt(deviation / float(len(allcoordsA)))
    
def mapToCrystal(xtal, pose):
    """Some docking programs might alter the order of the atoms in the output (like Autodock Vina does...)
     this will mess up the rmsd calculation with OpenBabel"""
    query = pybel.ob.CompileMoleculeQuery(xtal.OBMol) 
    mapper=pybel.ob.OBIsomorphismMapper.GetInstance(query)
    mappingpose = pybel.ob.vvpairUIntUInt()
    exit=mapper.MapUnique(pose.OBMol,mappingpose)
    return mappingpose[0]

def parseArguments():
	optparse.OptionParser.format_epilog = lambda self, formatter: self.epilog
	epilog = """Args:
	reference.sdf		SDF file with the reference molecule.
	input.sdf		SDF file with the molecules to be compared to reference.\n"""
	parser = optparse.OptionParser("usage: %prog [options] reference.sdf input.sdf", epilog=epilog)
	parser.add_option("-f", "--fit",dest="fit", action="store_true", default=False,
                  help="Superpose molecules before RMSD calculation")
	parser.add_option("-o","--out", dest="outfilename", metavar="FILE", default=False,
                  help="If declared, write an output SDF file with the input molecules with a new sdfield <RMSD>. If molecule was fitted, the fitted molecule coordinates will be saved.")
	(options, args) =  parser.parse_args()
	
	#Check we have two arguments
	if len(args) < 2:
		parser.error("Incorrect number of arguments. Use -h or --help options to print help.")

	return options, args

def updateCoords(obmol, newcoords):
    "Update OBMol coordinates. newcoords is a numpy array"
    for i,atom in enumerate(obmol):
        atom.OBAtom.SetVector(*newcoords[i])

    
if __name__ == "__main__":
    import sys
   
    (opts, args) = parseArguments() 
	
    xtal = args[0]
    poses = args[1]
    fit = opts.fit
    outfname = opts.outfilename

    # Read crystal pose
    crystal = next(pybel.readfile("sdf", xtal))
    crystal.removeh()
    crystalnumatoms = len(crystal.atoms)

    # Find automorphisms involving only non-H atoms
    mappings = pybel.ob.vvpairUIntUInt()
    bitvec = pybel.ob.OBBitVec()
    lookup = []
    for i, atom in enumerate(crystal):
        lookup.append(i)
    success = pybel.ob.FindAutomorphisms(crystal.OBMol, mappings)

    #If outfname is defined, prepare an output SDF sink to write molecules
    if outfname:
	outsdf = pybel.Outputfile('sdf', outfname, overwrite=True)

    # Find the RMSD between the crystal pose and each docked pose
    xtalcoords = [atom.coords for atom in crystal]
    dockedposes = pybel.readfile("sdf", poses)
    if fit: print "POSE\tRMSD_FIT"
    else: print "POSE\tRMSD_NOFIT"
    skipped = []
    for i, dockedpose in enumerate(dockedposes):
        dockedpose.removeh()
	natoms = len(dockedpose.atoms)
	if natoms != crystalnumatoms: 
		skipped.append(i)
		continue
        mappose = mapToCrystal(crystal, dockedpose)
        mappose = npy.array(mappose)
        mappose = mappose[npy.argsort(mappose[:,0])][:,1]
        posecoords = npy.array([atom.coords for atom in dockedpose])[mappose]
        resultrmsd = 999999999999
        for mapping in mappings:
            automorph_coords = [None] * len(xtalcoords)
            for x, y in mapping:
                automorph_coords[lookup.index(x)] = xtalcoords[lookup.index(y)]
            mapping_rmsd = rmsd(posecoords, automorph_coords)
            if mapping_rmsd < resultrmsd:
                resultrmsd = mapping_rmsd
		fitted_result = False
            if fit: 
		fitted_pose, fitted_rmsd = superpose3D(npy.array(automorph_coords), npy.array(posecoords))
            	if fitted_rmsd < resultrmsd:
                	resultrmsd = fitted_rmsd
			fitted_result = fitted_pose
	
	# Write molecule to ousdf if demanded
	if outfname:
		# Add RMSD field and save molecule
		newData = pybel.ob.OBPairData()	
		newData.SetAttribute("RMSD")
                newData.SetValue('%.3f'%resultrmsd)
		dockedpose.OBMol.CloneData(newData)           # Add new data

		# Update position if fit option
		if npy.any(fitted_result): updateCoords(dockedpose, fitted_result)

                outsdf.write(dockedpose)



	print "%d\t%.2f"%((i+1),resultrmsd)

    if skipped: print >> sys.stderr, "SKIPPED input molecules due to number of atom missmatch: %d"%skipped
